package clconnect

import (
	"context"
	"fmt"

	"connectrpc.com/connect"
	entsql "entgo.io/ent/dialect/sql"
	"github.com/crewlinker/clgo/clpostgres/cltx"
	"go.uber.org/fx"
	"go.uber.org/zap"
)

// EntModelTx is a generic type to constraint the tx to those generated by Ent.
type EntModelTx interface {
	Commit() error
	Rollback() error
}

// EntModelClient is a generic type to constraint the model client to those generated by Ent.
type EntModelClient[TX EntModelTx] interface {
	BeginTx(ctx context.Context, opts *entsql.TxOptions) (TX, error)
}

// EntROTransactor provides an ent tx to the context.
type EntROTransactor[TX EntModelTx, MC EntModelClient[TX]] struct {
	mc   MC
	logs *zap.Logger
	connect.Interceptor
}

// NewEntROTransactor its a RO transactor for the model client type.
func NewEntROTransactor[TX EntModelTx, MC EntModelClient[TX]](logs *zap.Logger, mc MC) *EntROTransactor[TX, MC] {
	intr := &EntROTransactor[TX, MC]{mc: mc, logs: logs.Named("ent_ro_transactor")}
	intr.Interceptor = connect.UnaryInterceptorFunc(intr.intercept)

	return intr
}

func (l EntROTransactor[TX, MC]) intercept(next connect.UnaryFunc) connect.UnaryFunc {
	return connect.UnaryFunc(func(
		ctx context.Context,
		req connect.AnyRequest,
	) (connect.AnyResponse, error) {
		return txEntIntercept[TX, MC](ctx, l.logs, req, l.mc, next, &entsql.TxOptions{
			ReadOnly: true,
		})
	})
}

// EntRWTransactor provides an ent tx to the context.
type EntRWTransactor[TX EntModelTx, MC EntModelClient[TX]] struct {
	mc   MC
	logs *zap.Logger
	connect.Interceptor
}

// NewEntRWTransactor its a RW transactor for the model client type.
func NewEntRWTransactor[TX EntModelTx, MC EntModelClient[TX]](logs *zap.Logger, mc MC) *EntRWTransactor[TX, MC] {
	intr := &EntRWTransactor[TX, MC]{mc: mc, logs: logs.Named("ent_rw_transactor")}
	intr.Interceptor = connect.UnaryInterceptorFunc(intr.intercept)

	return intr
}

func (l EntRWTransactor[TX, MC]) intercept(next connect.UnaryFunc) connect.UnaryFunc {
	return connect.UnaryFunc(func(
		ctx context.Context,
		req connect.AnyRequest,
	) (connect.AnyResponse, error) {
		return txEntIntercept[TX, MC](ctx, l.logs, req, l.mc, next, nil)
	})
}

// shared intercept logic for both RW and RW interceptors.
func txEntIntercept[TX EntModelTx, MC EntModelClient[TX]](
	ctx context.Context,
	logs *zap.Logger,
	req connect.AnyRequest,
	mc MC,
	next connect.UnaryFunc,
	opts *entsql.TxOptions,
) (connect.AnyResponse, error) {
	tx, err := mc.BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to begin tx: %w", err)
	}

	defer func() {
		if rberr := tx.Rollback(); rberr != nil {
			logs.Error("failed to rollback tx", zap.Error(err))
		}
	}()

	ctx = cltx.WithTx(ctx, tx)

	resp, err := next(ctx, req)
	if err != nil {
		return nil, err
	}

	if err := tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to commit tx: %w", err)
	}

	return resp, nil
}

// ProvideEntTransactors provides the RO transactor.
func ProvideEntTransactors[TX EntModelTx, MC EntModelClient[TX]]() fx.Option {
	return fx.Options(
		fx.Provide(fx.Annotate(NewEntROTransactor[TX, MC],
			fx.ParamTags(``, `name:"ro"`),
			fx.As(new(ROTransacter)))),
		fx.Provide(fx.Annotate(NewEntRWTransactor[TX, MC],
			fx.ParamTags(``, `name:"rw"`),
			fx.As(new(RWTransacter)))),
	)
}
